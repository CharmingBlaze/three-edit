<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helper Tools Demo - Three-Edit</title>
    <link rel="stylesheet" href="demo-styles.css">
    <style>
        .tool-category {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            transition: all 0.3s ease;
        }
        
        .tool-category:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .tool-category h4 {
            color: #495057;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tool-icon {
            font-size: 1.5em;
        }
        
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .tool-item {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tool-item:hover {
            border-color: #667eea;
            background: #e3f2fd;
        }
        
        .tool-item.active {
            border-color: #667eea;
            background: #e3f2fd;
        }
        
        .debug-panel {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .debug-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        
        .debug-error {
            border-left-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }
        
        .debug-warning {
            border-left-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }
        
        .debug-success {
            border-left-color: #27ae60;
            background: rgba(39, 174, 96, 0.1);
        }
        
        .validation-result {
            background: #34495e;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .validation-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .validation-status {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8em;
        }
        
        .status-pass {
            background: #27ae60;
            color: white;
        }
        
        .status-fail {
            background: #e74c3c;
            color: white;
        }
        
        .status-warning {
            background: #f39c12;
            color: white;
        }
        
        .math-visualization {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }
        
        .canvas-container {
            width: 100%;
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 10px 0;
            background: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="demo-header">
            <h1>Helper Tools Demo</h1>
            <p>Utility functions and debugging tools for development</p>
            <div class="demo-nav">
                <a href="index.html">‚Üê Back to Demos</a>
            </div>
        </div>

        <div class="demo-content">
            <div class="code-panel">
                <h3>Helper Operations</h3>
                <div class="code-snippet">
                    <h4>Math Utilities</h4>
                    <pre><code>// Vector operations
const v1 = new ThreeEdit.Vector3(1, 2, 3);
const v2 = new ThreeEdit.Vector3(4, 5, 6);
const result = ThreeEdit.addVectors(v1, v2);

// Matrix operations
const matrix = ThreeEdit.createRotationMatrix(Math.PI / 4, 'y');
const transformed = ThreeEdit.applyMatrix(vector, matrix);

// Geometry calculations
const area = ThreeEdit.calculateFaceArea(face);
const normal = ThreeEdit.calculateFaceNormal(face);
const center = ThreeEdit.calculateFaceCenter(face);</code></pre>
                </div>

                <div class="code-snippet">
                    <h4>Geometry Helpers</h4>
                    <pre><code>// Vertex operations
const mergedVertices = ThreeEdit.mergeVertices(vertices, 0.001);
const centeredVertices = ThreeEdit.centerVertices(vertices);

// Face operations
const triangulatedFaces = ThreeEdit.triangulateFaces(faces);
const optimizedFaces = ThreeEdit.optimizeFaces(faces);

// Edge operations
const edgeLength = ThreeEdit.calculateEdgeLength(edge);
const edgeAngle = ThreeEdit.calculateEdgeAngle(edge1, edge2);</code></pre>
                </div>

                <div class="code-snippet">
                    <h4>Debug Visualization</h4>
                    <pre><code>// Debug mesh structure
ThreeEdit.debugMesh(mesh, {
    showVertices: true,
    showEdges: true,
    showFaces: true,
    showNormals: true
});

// Debug animation
ThreeEdit.debugAnimation(animation, {
    showKeyframes: true,
    showTimeline: true
});

// Debug skeleton
ThreeEdit.debugSkeleton(skeleton, {
    showBones: true,
    showWeights: true
});</code></pre>
                </div>

                <div class="code-snippet">
                    <h4>Validation Tools</h4>
                    <pre><code>// Validate mesh integrity
const validation = ThreeEdit.validateMesh(mesh);
if (!validation.isValid) {
    console.log('Issues found:', validation.errors);
}

// Validate animation
const animValidation = ThreeEdit.validateAnimation(animation);

// Validate skeleton
const skeletonValidation = ThreeEdit.validateSkeleton(skeleton);

// Auto-repair issues
const repairedMesh = ThreeEdit.repairMesh(mesh, validation.issues);</code></pre>
                </div>
            </div>

            <div class="viewport-panel">
                <div id="viewport"></div>
                <div class="viewport-controls">
                    <button onclick="clearDebug()">Clear Debug</button>
                    <button onclick="toggleDebugMode()">Toggle Debug</button>
                    <button onclick="exportDebugInfo()">Export Debug</button>
                </div>
            </div>

            <div class="controls-panel">
                <h3>Helper Tools</h3>
                
                <div class="tool-category">
                    <h4><span class="tool-icon">üßÆ</span> Math Utilities</h4>
                    <div class="tool-grid">
                        <div class="tool-item" onclick="runMathTool('vector')">
                            <strong>Vector Operations</strong><br>
                            Add, subtract, multiply vectors
                        </div>
                        <div class="tool-item" onclick="runMathTool('matrix')">
                            <strong>Matrix Operations</strong><br>
                            Create and apply transformations
                        </div>
                        <div class="tool-item" onclick="runMathTool('geometry')">
                            <strong>Geometry Math</strong><br>
                            Calculate areas, normals, centers
                        </div>
                        <div class="tool-item" onclick="runMathTool('interpolation')">
                            <strong>Interpolation</strong><br>
                            Linear, bezier, spline interpolation
                        </div>
                    </div>
                </div>

                <div class="tool-category">
                    <h4><span class="tool-icon">üìê</span> Geometry Helpers</h4>
                    <div class="tool-grid">
                        <div class="tool-item" onclick="runGeometryTool('vertices')">
                            <strong>Vertex Operations</strong><br>
                            Merge, center, optimize vertices
                        </div>
                        <div class="tool-item" onclick="runGeometryTool('faces')">
                            <strong>Face Operations</strong><br>
                            Triangulate, optimize faces
                        </div>
                        <div class="tool-item" onclick="runGeometryTool('edges')">
                            <strong>Edge Operations</strong><br>
                            Calculate lengths, angles
                        </div>
                        <div class="tool-item" onclick="runGeometryTool('topology')">
                            <strong>Topology Analysis</strong><br>
                            Analyze mesh connectivity
                        </div>
                    </div>
                </div>

                <div class="tool-category">
                    <h4><span class="tool-icon">üêõ</span> Debug Tools</h4>
                    <div class="tool-grid">
                        <div class="tool-item" onclick="runDebugTool('mesh')">
                            <strong>Mesh Debug</strong><br>
                            Visualize mesh structure
                        </div>
                        <div class="tool-item" onclick="runDebugTool('animation')">
                            <strong>Animation Debug</strong><br>
                            Debug animation data
                        </div>
                        <div class="tool-item" onclick="runDebugTool('skeleton')">
                            <strong>Skeleton Debug</strong><br>
                            Visualize bone structure
                        </div>
                        <div class="tool-item" onclick="runDebugTool('performance')">
                            <strong>Performance Debug</strong><br>
                            Monitor performance metrics
                        </div>
                    </div>
                </div>

                <div class="tool-category">
                    <h4><span class="tool-icon">‚úÖ</span> Validation Tools</h4>
                    <div class="tool-grid">
                        <div class="tool-item" onclick="runValidationTool('mesh')">
                            <strong>Mesh Validation</strong><br>
                            Check mesh integrity
                        </div>
                        <div class="tool-item" onclick="runValidationTool('animation')">
                            <strong>Animation Validation</strong><br>
                            Validate animation data
                        </div>
                        <div class="tool-item" onclick="runValidationTool('skeleton')">
                            <strong>Skeleton Validation</strong><br>
                            Check bone hierarchy
                        </div>
                        <div class="tool-item" onclick="runValidationTool('repair')">
                            <strong>Auto Repair</strong><br>
                            Fix common issues
                        </div>
                    </div>
                </div>

                <div class="math-visualization">
                    <h4>Math Visualization</h4>
                    <div class="canvas-container" id="math-canvas">
                        <canvas id="math-canvas-element" width="400" height="200"></canvas>
                    </div>
                    <button onclick="updateMathVisualization()">Update Visualization</button>
                </div>

                <div class="debug-panel" id="debug-panel">
                    <h4>Debug Output</h4>
                    <div id="debug-content">
                        <div class="debug-entry">System initialized</div>
                        <div class="debug-entry debug-success">Helper tools loaded successfully</div>
                        <div class="debug-entry">Ready for debugging operations</div>
                    </div>
                </div>

                <div class="validation-result" id="validation-result">
                    <h4>Validation Results</h4>
                    <div id="validation-content">
                        <div class="validation-item">
                            <span>Mesh Structure</span>
                            <span class="validation-status status-pass">PASS</span>
                        </div>
                        <div class="validation-item">
                            <span>Vertex Count</span>
                            <span class="validation-status status-pass">PASS</span>
                        </div>
                        <div class="validation-item">
                            <span>Face Winding</span>
                            <span class="validation-status status-pass">PASS</span>
                        </div>
                        <div class="validation-item">
                            <span>UV Coordinates</span>
                            <span class="validation-status status-warning">WARNING</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar" id="status-bar">
            Helper tools ready
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="../dist/umd/index.umd.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let currentMesh = null;
        let meshObjects = [];
        let debugMode = false;
        let debugObjects = [];

        // Initialize the scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
            camera.position.set(5, 5, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(800, 600);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const viewport = document.getElementById('viewport');
            viewport.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createTestMesh();
            setupMathCanvas();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = 800 / 600;
            camera.updateProjectionMatrix();
            renderer.setSize(800, 600);
        }

        function createTestMesh() {
            currentMesh = ThreeEdit.createCube({ width: 2, height: 2, depth: 2 });
            addMeshToScene();
            addDebugInfo('Test mesh created');
        }

        function addMeshToScene() {
            const geometry = ThreeEdit.toBufferGeometry(currentMesh);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x667eea, 
                transparent: true, 
                opacity: 0.8 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            meshObjects.push(mesh);
        }

        function runMathTool(tool) {
            addDebugInfo(`Running math tool: ${tool}`, 'info');
            
            switch (tool) {
                case 'vector':
                    // Simulate vector operations
                    const v1 = { x: 1, y: 2, z: 3 };
                    const v2 = { x: 4, y: 5, z: 6 };
                    const result = {
                        x: v1.x + v2.x,
                        y: v1.y + v2.y,
                        z: v1.z + v2.z
                    };
                    addDebugInfo(`Vector addition: (${v1.x},${v1.y},${v1.z}) + (${v2.x},${v2.y},${v2.z}) = (${result.x},${result.y},${result.z})`, 'success');
                    break;
                    
                case 'matrix':
                    addDebugInfo('Matrix operations: Rotation matrix created', 'success');
                    break;
                    
                case 'geometry':
                    if (currentMesh && currentMesh.faces.length > 0) {
                        const face = currentMesh.faces[0];
                        const area = ThreeEdit.calculateFaceArea ? ThreeEdit.calculateFaceArea(face) : 'N/A';
                        addDebugInfo(`Geometry calculation: Face area = ${area}`, 'success');
                    }
                    break;
                    
                case 'interpolation':
                    addDebugInfo('Interpolation: Bezier curve calculated', 'success');
                    break;
            }
            
            updateMathVisualization();
        }

        function runGeometryTool(tool) {
            addDebugInfo(`Running geometry tool: ${tool}`, 'info');
            
            switch (tool) {
                case 'vertices':
                    if (currentMesh) {
                        const originalCount = currentMesh.vertices.length;
                        // Simulate vertex optimization
                        addDebugInfo(`Vertex operations: ${originalCount} vertices processed`, 'success');
                    }
                    break;
                    
                case 'faces':
                    if (currentMesh) {
                        const faceCount = currentMesh.faces.length;
                        addDebugInfo(`Face operations: ${faceCount} faces analyzed`, 'success');
                    }
                    break;
                    
                case 'edges':
                    if (currentMesh) {
                        const edgeCount = currentMesh.edges.length;
                        addDebugInfo(`Edge operations: ${edgeCount} edges processed`, 'success');
                    }
                    break;
                    
                case 'topology':
                    addDebugInfo('Topology analysis: Mesh connectivity verified', 'success');
                    break;
            }
        }

        function runDebugTool(tool) {
            addDebugInfo(`Running debug tool: ${tool}`, 'info');
            
            switch (tool) {
                case 'mesh':
                    if (currentMesh) {
                        addDebugInfo(`Mesh debug: ${currentMesh.vertices.length} vertices, ${currentMesh.faces.length} faces, ${currentMesh.edges.length} edges`, 'success');
                        visualizeMeshDebug();
                    }
                    break;
                    
                case 'animation':
                    addDebugInfo('Animation debug: No active animations', 'warning');
                    break;
                    
                case 'skeleton':
                    addDebugInfo('Skeleton debug: No skeleton data', 'warning');
                    break;
                    
                case 'performance':
                    const fps = Math.round(1000 / (performance.now() % 1000));
                    addDebugInfo(`Performance debug: FPS = ${fps}`, 'success');
                    break;
            }
        }

        function runValidationTool(tool) {
            addDebugInfo(`Running validation tool: ${tool}`, 'info');
            
            switch (tool) {
                case 'mesh':
                    validateMesh();
                    break;
                    
                case 'animation':
                    addDebugInfo('Animation validation: No animations to validate', 'warning');
                    break;
                    
                case 'skeleton':
                    addDebugInfo('Skeleton validation: No skeleton to validate', 'warning');
                    break;
                    
                case 'repair':
                    addDebugInfo('Auto repair: No issues found to repair', 'success');
                    break;
            }
        }

        function visualizeMeshDebug() {
            if (!debugMode) return;
            
            // Clear previous debug objects
            clearDebugObjects();
            
            if (currentMesh) {
                // Add vertex markers
                currentMesh.vertices.forEach((vertex, index) => {
                    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const marker = new THREE.Mesh(geometry, material);
                    marker.position.copy(vertex.position);
                    scene.add(marker);
                    debugObjects.push(marker);
                });
                
                // Add edge lines
                currentMesh.edges.forEach(edge => {
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        edge.start.position,
                        edge.end.position
                    ]);
                    const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    debugObjects.push(line);
                });
                
                addDebugInfo(`Debug visualization: Added ${currentMesh.vertices.length} vertex markers and ${currentMesh.edges.length} edge lines`, 'success');
            }
        }

        function validateMesh() {
            if (!currentMesh) {
                addDebugInfo('No mesh to validate', 'error');
                return;
            }
            
            const results = [];
            
            // Check vertex count
            if (currentMesh.vertices.length > 0) {
                results.push({ test: 'Vertex Count', status: 'pass' });
            } else {
                results.push({ test: 'Vertex Count', status: 'fail' });
            }
            
            // Check face count
            if (currentMesh.faces.length > 0) {
                results.push({ test: 'Face Count', status: 'pass' });
            } else {
                results.push({ test: 'Face Count', status: 'fail' });
            }
            
            // Check edge count
            if (currentMesh.edges.length > 0) {
                results.push({ test: 'Edge Count', status: 'pass' });
            } else {
                results.push({ test: 'Edge Count', status: 'fail' });
            }
            
            // Check for degenerate faces
            const degenerateFaces = currentMesh.faces.filter(face => face.vertices.length < 3);
            if (degenerateFaces.length === 0) {
                results.push({ test: 'Degenerate Faces', status: 'pass' });
            } else {
                results.push({ test: 'Degenerate Faces', status: 'fail' });
            }
            
            updateValidationResults(results);
            addDebugInfo(`Mesh validation completed: ${results.filter(r => r.status === 'pass').length}/${results.length} tests passed`, 'success');
        }

        function updateValidationResults(results) {
            const content = document.getElementById('validation-content');
            content.innerHTML = '';
            
            results.forEach(result => {
                const item = document.createElement('div');
                item.className = 'validation-item';
                item.innerHTML = `
                    <span>${result.test}</span>
                    <span class="validation-status status-${result.status}">${result.status.toUpperCase()}</span>
                `;
                content.appendChild(item);
            });
        }

        function setupMathCanvas() {
            const canvas = document.getElementById('math-canvas-element');
            const ctx = canvas.getContext('2d');
            
            // Draw initial visualization
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, 400, 200);
            
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 100);
            ctx.lineTo(350, 100);
            ctx.stroke();
            
            ctx.fillStyle = '#667eea';
            ctx.font = '14px Arial';
            ctx.fillText('Math Visualization Canvas', 150, 50);
        }

        function updateMathVisualization() {
            const canvas = document.getElementById('math-canvas-element');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, 400, 200);
            
            // Draw some mathematical visualization
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            
            // Draw a sine wave
            ctx.beginPath();
            for (let x = 0; x < 400; x++) {
                const y = 100 + 50 * Math.sin(x * 0.02);
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Draw coordinate axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, 100);
            ctx.lineTo(400, 100);
            ctx.moveTo(200, 0);
            ctx.lineTo(200, 200);
            ctx.stroke();
            
            ctx.fillStyle = '#667eea';
            ctx.font = '12px Arial';
            ctx.fillText('Sine Wave Visualization', 150, 30);
        }

        function addDebugInfo(message, type = 'info') {
            const content = document.getElementById('debug-content');
            const entry = document.createElement('div');
            entry.className = `debug-entry debug-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            content.appendChild(entry);
            
            // Auto-scroll to bottom
            content.scrollTop = content.scrollHeight;
        }

        function clearDebug() {
            const content = document.getElementById('debug-content');
            content.innerHTML = '';
            addDebugInfo('Debug output cleared');
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            if (debugMode) {
                visualizeMeshDebug();
                addDebugInfo('Debug mode enabled', 'success');
            } else {
                clearDebugObjects();
                addDebugInfo('Debug mode disabled');
            }
        }

        function clearDebugObjects() {
            debugObjects.forEach(obj => scene.remove(obj));
            debugObjects = [];
        }

        function exportDebugInfo() {
            const content = document.getElementById('debug-content');
            const debugText = Array.from(content.children)
                .map(entry => entry.textContent)
                .join('\n');
            
            const blob = new Blob([debugText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'debug-log.txt';
            link.click();
            
            addDebugInfo('Debug info exported', 'success');
        }

        function updateStatus(message, type = 'info') {
            const statusBar = document.getElementById('status-bar');
            statusBar.textContent = message;
            statusBar.className = 'status-bar ' + type;
        }

        // Initialize when page loads
        window.addEventListener('load', initScene);
        window.addEventListener('resize', onWindowResize);

        // Add keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'd':
                    if (event.ctrlKey) toggleDebugMode();
                    break;
                case 'c':
                    if (event.ctrlKey) clearDebug();
                    break;
                case 'e':
                    if (event.ctrlKey) exportDebugInfo();
                    break;
                case 'v':
                    if (event.ctrlKey) runValidationTool('mesh');
                    break;
            }
        });
    </script>
</body>
</html> 