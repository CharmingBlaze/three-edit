<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Mesh System Demo - Three-Edit</title>
    <link rel="stylesheet" href="demo-styles.css">
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/controls/TransformControls.js"></script>
    <script type="module">
        // Import ThreeEdit from the demo shim system
        import { io, core, ops, easy } from "../../demo/te.js";
        
        // Make ThreeEdit available globally for the demo
        window.ThreeEdit = { io, core, ops, easy };
        
        console.log('ThreeEdit loaded via demo shim:', window.ThreeEdit);
    </script>
</head>
<body>
    <div class="container">
        <div class="demo-header">
            <h1>Core Mesh System</h1>
            <p>Understanding the fundamental structure: Vertices, Edges, and Faces</p>
            <div class="demo-instructions">
                <p><strong>How to use:</strong></p>
                <ol>
                    <li>Enable <strong>Selection Mode</strong> to click and select objects</li>
                    <li>Click on a mesh to select it and show the transform gizmo</li>
                    <li>Use the gizmo handles to move, rotate, or scale the selected mesh</li>
                    <li>Change transform mode using the dropdown (Move/Rotate/Scale)</li>
                    <li>Clear selection to hide the gizmo</li>
                </ol>
            </div>
            <a href="index.html" class="back-link">‚Üê Back to Demos</a>
        </div>

        <div class="demo-nav">
            <div class="nav-section">
                <button class="nav-button active" onclick="showSection('basics')">Mesh Basics</button>
                <button class="nav-button" onclick="showSection('vertices')">Vertices</button>
                <button class="nav-button" onclick="showSection('edges')">Edges</button>
                <button class="nav-button" onclick="showSection('faces')">Faces</button>
                <button class="nav-button" onclick="showSection('topology')">Topology</button>
            </div>
            <div class="nav-section">
                <button class="nav-button" onclick="resetScene()">Reset</button>
                <button class="nav-button" onclick="toggleWireframe()">Wireframe</button>
            </div>
        </div>

        <div class="demo-content">
            <div class="code-panel">
                <div id="basics-code" class="code-section">
                    <h3>Mesh Basics</h3>
                    <div class="code-block">
<span class="code-comment">// Create a basic mesh structure</span>
<span class="code-keyword">const</span> mesh = <span class="code-function">ThreeEdit</span>.<span class="code-function">createCube</span>();

<span class="code-comment">// Access mesh components</span>
<span class="code-keyword">const</span> vertices = mesh.<span class="code-function">vertices</span>;
<span class="code-keyword">const</span> edges = mesh.<span class="code-function">edges</span>;
<span class="code-keyword">const</span> faces = mesh.<span class="code-function">faces</span>;

<span class="code-comment">// Mesh properties</span>
console.<span class="code-function">log</span>(<span class="code-string">'Vertices:'</span>, vertices.<span class="code-function">length</span>);
console.<span class="code-function">log</span>(<span class="code-string">'Edges:'</span>, edges.<span class="code-function">length</span>);
console.<span class="code-function">log</span>(<span class="code-string">'Faces:'</span>, faces.<span class="code-function">length</span>);
                    </div>
                </div>

                <div id="vertices-code" class="code-section hidden">
                    <h3>Vertex Operations</h3>
                    <div class="code-block">
<span class="code-comment">// Create a vertex</span>
<span class="code-keyword">const</span> vertex = <span class="code-keyword">new</span> <span class="code-function">ThreeEdit</span>.<span class="code-function">Vertex</span>(<span class="code-number">1</span>, <span class="code-number">2</span>, <span class="code-number">3</span>);

<span class="code-comment">// Access vertex properties</span>
console.<span class="code-function">log</span>(<span class="code-string">'Position:'</span>, vertex.<span class="code-function">position</span>);
console.<span class="code-function">log</span>(<span class="code-string">'Normal:'</span>, vertex.<span class="code-function">normal</span>);
console.<span class="code-function">log</span>(<span class="code-string">'UV:'</span>, vertex.<span class="code-function">uv</span>);

<span class="code-comment">// Modify vertex position</span>
vertex.<span class="code-function">position</span>.<span class="code-function">set</span>(<span class="code-number">2</span>, <span class="code-number">3</span>, <span class="code-number">4</span>);

<span class="code-comment">// Add vertex to mesh</span>
mesh.<span class="code-function">addVertex</span>(vertex);
                    </div>
                </div>

                <div id="edges-code" class="code-section hidden">
                    <h3>Edge Operations</h3>
                    <div class="code-block">
<span class="code-comment">// Create an edge between two vertices</span>
<span class="code-keyword">const</span> edge = <span class="code-keyword">new</span> <span class="code-function">ThreeEdit</span>.<span class="code-function">Edge</span>(vertex1, vertex2);

<span class="code-comment">// Access edge properties</span>
console.<span class="code-function">log</span>(<span class="code-string">'Start vertex:'</span>, edge.<span class="code-function">start</span>);
console.<span class="code-function">log</span>(<span class="code-string">'End vertex:'</span>, edge.<span class="code-function">end</span>);
console.<span class="code-function">log</span>(<span class="code-string">'Connected faces:'</span>, edge.<span class="code-function">faces</span>.<span class="code-function">length</span>);

<span class="code-comment">// Check if edge is boundary</span>
<span class="code-keyword">const</span> isBoundary = edge.<span class="code-function">isBoundary</span>();

<span class="code-comment">// Add edge to mesh</span>
mesh.<span class="code-function">addEdge</span>(edge);
                    </div>
                </div>

                <div id="faces-code" class="code-section hidden">
                    <h3>Face Operations</h3>
                    <div class="code-block">
<span class="code-comment">// Create a face from vertices</span>
<span class="code-keyword">const</span> face = <span class="code-keyword">new</span> <span class="code-function">ThreeEdit</span>.<span class="code-function">Face</span>([vertex1, vertex2, vertex3]);

<span class="code-comment">// Access face properties</span>
console.<span class="code-function">log</span>(<span class="code-string">'Vertices:'</span>, face.<span class="code-function">vertices</span>.<span class="code-function">length</span>);
console.<span class="code-function">log</span>(<span class="code-string">'Edges:'</span>, face.<span class="code-function">edges</span>.<span class="code-function">length</span>);
console.<span class="code-function">log</span>(<span class="code-string">'Normal:'</span>, face.<span class="code-function">normal</span>);

<span class="code-comment">// Calculate face properties</span>
<span class="code-keyword">const</span> center = face.<span class="code-function">getCenter</span>();
<span class="code-keyword">const</span> area = face.<span class="code-function">getArea</span>();

<span class="code-comment">// Add face to mesh</span>
mesh.<span class="code-function">addFace</span>(face);
                    </div>
                </div>

                <div id="topology-code" class="code-section hidden">
                    <h3>Topology Management</h3>
                    <div class="code-block">
<span class="code-comment">// Validate mesh topology</span>
<span class="code-keyword">const</span> validation = <span class="code-function">ThreeEdit</span>.<span class="code-function">validateMesh</span>(mesh);
console.<span class="code-function">log</span>(<span class="code-string">'Is valid:'</span>, validation.<span class="code-function">isValid</span>);

<span class="code-comment">// Fix topology issues</span>
<span class="code-keyword">if</span> (!validation.<span class="code-function">isValid</span>) {
    <span class="code-function">ThreeEdit</span>.<span class="code-function">repairMesh</span>(mesh);
}

<span class="code-comment">// Merge duplicate vertices</span>
<span class="code-keyword">const</span> result = <span class="code-function">ThreeEdit</span>.<span class="code-function">mergeVertices</span>(mesh.<span class="code-function">vertices</span>, <span class="code-number">0.001</span>);

<span class="code-comment">// Update mesh with cleaned vertices</span>
mesh.<span class="code-function">vertices</span> = result.<span class="code-function">newVertices</span>;
                    </div>
                </div>
            </div>

            <div class="viewport-panel">
                <div class="viewport-container" id="viewport">
                    <div class="loading">
                        <div class="spinner"></div>
                        Loading 3D Scene...
                    </div>
                </div>
                <div class="viewport-info">
                    <div id="mesh-info">Click on mesh elements to see information</div>
                </div>
            </div>
        </div>

        <div class="controls-panel">
            <div class="controls-grid">
                <div class="control-group">
                    <h4>Mesh Creation</h4>
                    <div class="control-item">
                        <button class="btn btn-primary" onclick="createCube()">Create Cube (ThreeEdit)</button>
                    </div>
                    <div class="control-item">
                        <button class="btn btn-primary" onclick="createFallbackCube()">Create Fallback Cube</button>
                    </div>
                </div>

                <div class="control-group">
                    <h4>Mesh Operations</h4>
                    <div class="control-item">
                        <button class="btn btn-secondary" onclick="addRandomVertex()">Add Random Vertex</button>
                    </div>
                    <div class="control-item">
                        <button class="btn btn-secondary" onclick="mergeVertices()">Merge Vertices</button>
                    </div>
                    <div class="control-item">
                        <button class="btn btn-success" onclick="validateMesh()">Validate Mesh</button>
                    </div>
                    <div class="control-item">
                        <button class="btn btn-danger" onclick="clearScene()">Clear Scene</button>
                    </div>
                </div>

                <div class="control-group">
                    <h4>Debug & Visualization</h4>
                    <div class="control-item">
                        <label>
                            <input type="checkbox" id="debug-mode" onchange="toggleDebugMode()">
                            Debug Mode
                        </label>
                    </div>
                    <div class="control-item">
                        <label>
                            <input type="checkbox" id="show-wireframe" checked onchange="toggleWireframe()">
                            Show Wireframe
                        </label>
                    </div>
                    <div class="control-item">
                        <button class="btn btn-warning" onclick="clearDebugVisualizations()">Clear Debug</button>
                    </div>
                </div>

                <div class="control-group">
                    <h4>Selection & Transform</h4>
                    <div class="control-item">
                        <label>
                            <input type="checkbox" id="selection-mode" onchange="toggleSelectionMode()">
                            Selection Mode
                        </label>
                    </div>
                    <div class="control-item">
                        <button class="btn btn-info" onclick="clearSelection()">Clear Selection</button>
                    </div>
                    <div class="control-item">
                        <button class="btn btn-secondary" onclick="resetMeshTransform()">Reset Transform</button>
                    </div>
                    <div class="control-item">
                        <button class="btn btn-warning" onclick="testGizmoSystem()">Test Gizmo System</button>
                    </div>
                    <div class="control-item">
                        <label>Transform Mode:</label>
                        <select id="transform-mode" onchange="changeTransformMode()" aria-label="Transform mode selection">
                            <option value="translate">Move</option>
                            <option value="rotate">Rotate</option>
                            <option value="scale">Scale</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="status-indicator"></div>
                <span id="status-text">Ready</span>
            </div>
            <div class="status-item">
                <span id="selection-info">No selection</span>
            </div>
        </div>

        <!-- Mesh Info Display -->
        <div class="mesh-info-panel">
            <div class="mesh-stats">
                <div class="stat-item">
                    <label>Vertices:</label>
                    <span id="vertex-count">0</span>
                </div>
                <div class="stat-item">
                    <label>Edges:</label>
                    <span id="edge-count">0</span>
                </div>
                <div class="stat-item">
                    <label>Faces:</label>
                    <span id="face-count">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let currentMesh = null;
        let meshObjects = [];
        let selectedElement = null;
        let debugMode = false;
        let debugObjects = [];
        let selectionMode = false;
        let transformControls = null;
        let selectedMesh = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Disable debug visualizations by default
        // This prevents unwanted debug lines from appearing when moving objects
        window.DEBUG_VISUALIZATIONS_ENABLED = false;
        window.DEBUG_MODE_DEFAULT = false;

        // Initialize the scene
        function initScene() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Create renderer with better error handling
            const container = document.getElementById('viewport');
            
            // Clear any existing content
            container.innerHTML = '';
            
            try {
                // Try to create WebGL renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                
                // Set renderer size
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Append renderer to container
                container.appendChild(renderer.domElement);
                
            } catch (error) {
                // Fallback to basic error message if WebGL fails
                container.innerHTML = `
                    <div style="color: white; text-align: center; padding: 50px;">
                        <h3>WebGL Error</h3>
                        <p>Could not initialize WebGL renderer: ${error.message}</p>
                        <p>Please try refreshing the page or check your browser's WebGL support.</p>
                    </div>
                `;
                updateStatus('WebGL initialization failed: ' + error.message, 'error');
                return;
            }

            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Add grid
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);

            // Initialize transform controls
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', function(event) {
                controls.enabled = !event.value;
            });
            transformControls.addEventListener('change', function() {
                // Update editable mesh when transform changes
                updateEditableMesh();
            });
            transformControls.addEventListener('mouseDown', function() {
                // Disable orbit controls when using transform controls
                controls.enabled = false;
            });
            transformControls.addEventListener('mouseUp', function() {
                // Re-enable orbit controls when done with transform
                controls.enabled = true;
            });
            scene.add(transformControls);

            // Clear any existing debug visualizations
            clearDebugVisualizations();

            // Start animation loop
            animate();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Mouse event handlers for selection
        function onMouseClick(event) {
            if (!selectionMode || !renderer) return;

            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Raycast to find clicked object
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshObjects.filter(obj => obj.type === 'Mesh'));

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                selectMesh(clickedMesh);
            } else {
                clearSelection();
            }
        }

        function selectMesh(mesh) {
            try {
                console.log('Selecting mesh:', mesh);
                
                // Clear previous selection
                if (selectedMesh) {
                    selectedMesh.material.emissive.setHex(0x000000);
                }

                // Select new mesh
                selectedMesh = mesh;
                selectedMesh.material.emissive.setHex(0x333333);

                // Attach transform controls to selected mesh
                if (transformControls) {
                    transformControls.attach(selectedMesh);
                    
                    // Set the transform mode based on the dropdown
                    const transformMode = document.getElementById('transform-mode').value;
                    transformControls.setMode(transformMode);
                    
                    console.log('Transform controls attached to mesh, mode:', transformMode);
                } else {
                    console.error('Transform controls not initialized');
                }

                // Update status
                updateStatus('Mesh selected - use gizmo to transform');
                updateSelectionInfo('Mesh selected');
                
            } catch (error) {
                console.error('Error selecting mesh:', error);
                updateStatus('Error selecting mesh: ' + error.message, 'error');
            }
        }

        function clearSelection() {
            if (selectedMesh) {
                selectedMesh.material.emissive.setHex(0x000000);
                selectedMesh = null;
            }

            // Detach transform controls
            transformControls.detach();

            // Update status
            updateStatus('Selection cleared');
            updateSelectionInfo('No selection');
        }

        // Reset mesh transform after applying changes
        function resetMeshTransform() {
            if (!selectedMesh) return;
            
            // Reset the mesh transform
            selectedMesh.position.set(0, 0, 0);
            selectedMesh.rotation.set(0, 0, 0);
            selectedMesh.scale.set(1, 1, 1);
            
            // Update the transform controls
            transformControls.updateMatrixWorld();
            
            updateStatus('Mesh transform reset');
        }

        function animate() {
            if (!renderer || !scene || !camera) return;
            
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            if (!renderer || !camera) return;
            
            const container = document.getElementById('viewport');
            if (!container) return;
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Update camera aspect ratio
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            // Update renderer size
            renderer.setSize(width, height);
        }

        // Section navigation
        function showSection(sectionName) {
            // Hide all code sections
            document.querySelectorAll('.code-section').forEach(section => {
                section.classList.add('hidden');
            });

            // Show selected section
            document.getElementById(sectionName + '-code').classList.remove('hidden');

            // Update navigation buttons
            document.querySelectorAll('.nav-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update status
            updateStatus('Showing ' + sectionName + ' section');
        }

        // Mesh creation functions
        function createCube() {
            clearScene();
            
            try {
                // Check if ThreeEdit is available
                if (typeof ThreeEdit === 'undefined') {
                    throw new Error('ThreeEdit library not loaded');
                }
                
                // Check if core module exists and has createCube function
                if (!ThreeEdit.core || typeof ThreeEdit.core.createCube !== 'function') {
                    throw new Error('ThreeEdit.core.createCube function not found. Available modules: ' + Object.keys(ThreeEdit));
                }
                
                // Create cube using ThreeEdit
                currentMesh = ThreeEdit.core.createCube({ width: 2, height: 2, depth: 2 });
                console.log('Cube created:', currentMesh);
                
                // Convert to Three.js geometry
                if (!ThreeEdit.io || typeof ThreeEdit.io.toBufferGeometry !== 'function') {
                    throw new Error('ThreeEdit.io.toBufferGeometry function not found');
                }
                
                const geometry = ThreeEdit.io.toBufferGeometry(currentMesh);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x667eea,
                    transparent: true,
                    opacity: 0.8
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = { type: 'mesh', editableMesh: currentMesh };
                scene.add(mesh);
                meshObjects.push(mesh);

                // Add wireframe
                const wireframe = new THREE.WireframeGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                const wireframeMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
                wireframeMesh.userData = { type: 'wireframe', parentMesh: mesh };
                scene.add(wireframeMesh);
                meshObjects.push(wireframeMesh);

                // Prevent debug visualizations from appearing
                preventDebugVisualizations();

                updateMeshInfo();
                updateStatus('Cube created successfully');
                
            } catch (error) {
                console.error('Error creating cube:', error);
                updateStatus('Error creating cube: ' + error.message, 'error');
                
                // Show error in viewport
                const container = document.getElementById('viewport');
                container.innerHTML = `
                    <div style="color: white; text-align: center; padding: 50px;">
                        <h3>Cube Creation Error</h3>
                        <p>${error.message}</p>
                        <p>Check console for more details.</p>
                    </div>
                `;
            }
        }

        // Fallback cube creation using Three.js directly (for testing gizmos)
        function createFallbackCube() {
            clearScene();
            
            try {
                // Create a basic cube using Three.js geometry
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x667eea,
                    transparent: true,
                    opacity: 0.8
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = { type: 'mesh', isFallback: true };
                scene.add(mesh);
                meshObjects.push(mesh);

                // Add wireframe
                const wireframe = new THREE.WireframeGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                const wireframeMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
                wireframeMesh.userData = { type: 'wireframe', parentMesh: mesh };
                scene.add(wireframeMesh);
                meshObjects.push(wireframeMesh);

                // Set current mesh for compatibility
                currentMesh = { vertices: [], edges: [], faces: [] };

                updateMeshInfo();
                updateStatus('Fallback cube created successfully (Three.js only)');
                
            } catch (error) {
                console.error('Error creating fallback cube:', error);
                updateStatus('Error creating fallback cube: ' + error.message, 'error');
            }
        }

        function createSphere() {
            clearScene();
            
            try {
                // Check if ThreeEdit is available
                if (typeof ThreeEdit === 'undefined') {
                    throw new Error('ThreeEdit library not loaded');
                }
                
                // Check if core module exists and has createSphere function
                if (!ThreeEdit.core || typeof ThreeEdit.core.createSphere !== 'function') {
                    throw new Error('ThreeEdit.core.createSphere function not found');
                }
                
                // Create sphere using ThreeEdit
                currentMesh = ThreeEdit.core.createSphere({ radius: 1, segments: 16 });
                
                // Convert to Three.js geometry
                if (!ThreeEdit.io || typeof ThreeEdit.io.toBufferGeometry !== 'function') {
                    throw new Error('ThreeEdit.io.toBufferGeometry function not found');
                }
                
                const geometry = ThreeEdit.io.toBufferGeometry(currentMesh);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x764ba2,
                    transparent: true,
                    opacity: 0.8
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = { type: 'mesh', editableMesh: currentMesh };
                scene.add(mesh);
                meshObjects.push(mesh);

                // Add wireframe
                const wireframe = new THREE.WireframeGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                const wireframeMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
                wireframeMesh.userData = { type: 'wireframe', parentMesh: mesh };
                scene.add(wireframeMesh);
                meshObjects.push(wireframeMesh);

                // Prevent debug visualizations from appearing
                preventDebugVisualizations();

                updateMeshInfo();
                updateStatus('Sphere created successfully');
                
            } catch (error) {
                console.error('Error creating sphere:', error);
                updateStatus('Error creating sphere: ' + error.message, 'error');
            }
        }

        function addRandomVertex() {
            if (!currentMesh) {
                updateStatus('No mesh to add vertex to', 'error');
                return;
            }

            try {
                // Check if core module has Vertex class
                if (!ThreeEdit.core || !ThreeEdit.core.Vertex) {
                    throw new Error('ThreeEdit.core.Vertex class not found');
                }
                
                // Create random vertex
                const x = (Math.random() - 0.5) * 4;
                const y = (Math.random() - 0.5) * 4;
                const z = (Math.random() - 0.5) * 4;
                
                const vertex = new ThreeEdit.core.Vertex(x, y, z);
                currentMesh.addVertex(vertex);

                // Visualize the vertex
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                scene.add(sphere);
                meshObjects.push(sphere);

                updateMeshInfo();
                updateStatus('Random vertex added');
                
            } catch (error) {
                console.error('Error adding vertex:', error);
                updateStatus('Error adding vertex: ' + error.message, 'error');
            }
        }

        function mergeVertices() {
            if (!currentMesh) {
                updateStatus('No mesh to merge vertices', 'error');
                return;
            }

            try {
                // Check if ops module has mergeVertices function
                if (!ThreeEdit.ops || typeof ThreeEdit.ops.mergeVertices !== 'function') {
                    throw new Error('ThreeEdit.ops.mergeVertices function not found');
                }
                
                const result = ThreeEdit.ops.mergeVertices(currentMesh.vertices, 0.1);
                currentMesh.vertices = result.newVertices;
                
                updateMeshInfo();
                updateStatus('Vertices merged: ' + result.newVertices.length + ' remaining');
                
            } catch (error) {
                console.error('Error merging vertices:', error);
                updateStatus('Error merging vertices: ' + error.message, 'error');
            }
        }

        function validateMesh() {
            if (!currentMesh) {
                updateStatus('No mesh to validate', 'error');
                return;
            }

            try {
                // Check if ops module has validateMesh function
                if (!ThreeEdit.ops || typeof ThreeEdit.ops.validateMesh !== 'function') {
                    throw new Error('ThreeEdit.ops.validateMesh function not found');
                }
                
                const validation = ThreeEdit.ops.validateMesh(currentMesh);
                
                if (validation.isValid) {
                    updateStatus('Mesh is valid', 'success');
                } else {
                    updateStatus('Mesh has issues: ' + validation.errors.join(', '), 'warning');
                }
                
            } catch (error) {
                console.error('Error validating mesh:', error);
                updateStatus('Error validating mesh: ' + error.message, 'error');
            }
        }

        function clearScene() {
            meshObjects.forEach(obj => scene.remove(obj));
            meshObjects = [];
            currentMesh = null;
            
            // Clear selection and transform controls
            clearSelection();
            
            // Clear debug visualizations as well
            clearDebugVisualizations();
            
            updateMeshInfo();
            updateStatus('Scene cleared');
        }

        // Cleanup function to dispose of renderer and prevent context conflicts
        function cleanupRenderer() {
            if (renderer) {
                // Dispose of geometries and materials
                scene.traverse((object) => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
                
                // Dispose of renderer
                renderer.dispose();
                renderer = null;
            }
            
            // Clear scene
            if (scene) {
                scene.clear();
            }
        }

        function resetScene() {
            clearScene();
            createCube();
        }

        function toggleWireframe() {
            // Implementation for wireframe toggle
            updateStatus('Wireframe toggle not implemented yet');
        }

        // Debug control functions
        function toggleDebugMode() {
            debugMode = document.getElementById('debug-mode').checked;
            if (debugMode) {
                updateStatus('Debug mode enabled - visualizations may appear');
            } else {
                updateStatus('Debug mode disabled');
                clearDebugVisualizations();
            }
        }

        function clearDebugVisualizations() {
            // Remove all debug objects from scene
            debugObjects.forEach(obj => {
                scene.remove(obj);
            });
            debugObjects = [];
            updateStatus('Debug visualizations cleared');
        }

        // Prevent debug visualizations from being created during normal operations
        function preventDebugVisualizations() {
            if (!debugMode && !window.DEBUG_VISUALIZATIONS_ENABLED) {
                // Clear any debug objects that might have been created
                clearDebugVisualizations();
            }
        }

        // Selection and transform control functions
        function toggleSelectionMode() {
            if (!renderer) {
                updateStatus('Renderer not initialized', 'error');
                return;
            }
            
            selectionMode = document.getElementById('selection-mode').checked;
            if (selectionMode) {
                updateStatus('Selection mode enabled - click on objects to select');
                // Add click event listener
                renderer.domElement.addEventListener('click', onMouseClick);
            } else {
                updateStatus('Selection mode disabled');
                // Remove click event listener
                renderer.domElement.removeEventListener('click', onMouseClick);
                clearSelection();
            }
        }

        function changeTransformMode() {
            if (!selectedMesh) return;
            
            const mode = document.getElementById('transform-mode').value;
            
            // Update the transform controls mode
            transformControls.setMode(mode);
            
            // Update the gizmo appearance
            transformControls.updateMatrixWorld();
            
            let modeName = 'Move';
            if (mode === 'rotate') modeName = 'Rotate';
            else if (mode === 'scale') modeName = 'Scale';
            
            updateStatus(`Transform mode changed to ${modeName} - gizmo updated`);
        }

        // Update editable mesh when transform controls are used
        function updateEditableMesh() {
            if (!selectedMesh || !selectedMesh.userData.editableMesh) return;
            
            const editableMesh = selectedMesh.userData.editableMesh;
            const position = selectedMesh.position;
            const rotation = selectedMesh.rotation;
            const scale = selectedMesh.scale;
            
            // Create a matrix to apply all transformations
            const matrix = new THREE.Matrix4();
            matrix.compose(position, new THREE.Quaternion().setFromEuler(rotation), scale);
            
            // Apply transformations to all vertices in the editable mesh
            editableMesh.vertices.forEach(vertex => {
                // Create a vector for the vertex position
                const vertexVector = new THREE.Vector3(vertex.x, vertex.y, vertex.z);
                
                // Apply the transformation matrix
                vertexVector.applyMatrix4(matrix);
                
                // Update the vertex position
                vertex.x = vertexVector.x;
                vertex.y = vertexVector.y;
                vertex.z = vertexVector.z;
            });
            
            // Update the visual mesh geometry to reflect changes
            updateMeshGeometry(selectedMesh, editableMesh);
            
            updateStatus('Mesh transformed and updated');
        }

        // Update the visual mesh geometry to reflect changes in the editable mesh
        function updateMeshGeometry(threeMesh, editableMesh) {
            try {
                // Check if io module has toBufferGeometry function
                if (!ThreeEdit.io || typeof ThreeEdit.io.toBufferGeometry !== 'function') {
                    throw new Error('ThreeEdit.io.toBufferGeometry function not found');
                }
                
                // Convert the updated editable mesh back to Three.js geometry
                const newGeometry = ThreeEdit.io.toBufferGeometry(editableMesh);
                
                // Update the mesh geometry
                threeMesh.geometry.dispose();
                threeMesh.geometry = newGeometry;
                
                // Update the wireframe if it exists
                const wireframe = meshObjects.find(obj => 
                    obj.userData.type === 'wireframe' && 
                    obj.userData.parentMesh === threeMesh
                );
                
                if (wireframe) {
                    wireframe.geometry.dispose();
                    wireframe.geometry = new THREE.WireframeGeometry(newGeometry);
                }
                
                // Reset the mesh transform since we've applied it to the vertices
                threeMesh.position.set(0, 0, 0);
                threeMesh.rotation.set(0, 0, 0);
                threeMesh.scale.set(1, 1, 1);
                
                // Update mesh info display
                updateMeshInfo();
                
            } catch (error) {
                console.error('Error updating mesh geometry:', error);
                updateStatus('Error updating mesh geometry: ' + error.message, 'error');
            }
        }

        // Test function to verify gizmo system is working and add debugging information
        function testGizmoSystem() {
            console.log('Testing gizmo system...');
            console.log('Scene:', scene);
            console.log('Camera:', camera);
            console.log('Renderer:', renderer);
            console.log('TransformControls:', transformControls);
            console.log('Mesh objects:', meshObjects);
            console.log('Selected mesh:', selectedMesh);
            
            if (transformControls) {
                console.log('TransformControls mode:', transformControls.getMode());
                console.log('TransformControls attached object:', transformControls.object);
            }
            
            updateStatus('Gizmo system test completed - check console');
        }

        // Utility functions
        function updateMeshInfo() {
            if (currentMesh) {
                document.getElementById('vertex-count').textContent = currentMesh.vertices.length;
                document.getElementById('edge-count').textContent = currentMesh.edges.length;
                document.getElementById('face-count').textContent = currentMesh.faces.length;
            } else {
                document.getElementById('vertex-count').textContent = '0';
                document.getElementById('edge-count').textContent = '0';
                document.getElementById('face-count').textContent = '0';
            }
        }

        function updateStatus(message, type = 'info') {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            statusText.textContent = message;
            
            indicator.className = 'status-indicator';
            if (type === 'error') {
                indicator.classList.add('error');
            } else if (type === 'warning') {
                indicator.classList.add('warning');
            }
        }

        function updateSelectionInfo(message) {
            document.getElementById('selection-info').textContent = message;
        }

        // Initialize when page loads
        window.addEventListener('load', function() {
            // Check if ThreeEdit is available
            if (typeof ThreeEdit === 'undefined') {
                updateStatus('ThreeEdit library not loaded. Please include the UMD build.', 'error');
                
                // Show error in viewport
                const container = document.getElementById('viewport');
                container.innerHTML = `
                    <div style="color: white; text-align: center; padding: 50px;">
                        <h3>ThreeEdit Library Error</h3>
                        <p>The ThreeEdit library could not be loaded.</p>
                        <p>Please ensure the demo shim is working correctly.</p>
                        <p>Error: ThreeEdit is undefined</p>
                    </div>
                `;
                return;
            }
            
            // Log successful loading
            console.log('ThreeEdit library loaded successfully:', ThreeEdit);
            console.log('Available modules:', Object.keys(ThreeEdit));
            console.log('Core module:', ThreeEdit.core);
            console.log('Ops module:', ThreeEdit.ops);
            console.log('Easy module:', ThreeEdit.easy);
            
            // Ensure debug visualizations are disabled by default
            window.DEBUG_VISUALIZATIONS_ENABLED = false;
            window.DEBUG_MODE_DEFAULT = false;
            
            initScene();
            createCube();
        });

        // Cleanup when page unloads to prevent context conflicts
        window.addEventListener('beforeunload', function() {
            cleanupRenderer();
        });

        // Also cleanup on page hide to handle tab switching
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // Page is hidden, cleanup resources
                if (renderer) {
                    renderer.dispose();
                    renderer = null;
                }
            }
        });
    </script>
</body>
</html> 