<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scene Graph Demo - Three-Edit</title>
    <link rel="stylesheet" href="demo-styles.css">
    <style>
        .scene-tree {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .tree-node {
            margin-left: 20px;
            padding: 2px 0;
        }
        
        .tree-node.selected {
            background: #3498db;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .node-info {
            background: #34495e;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .node-property {
            color: #3498db;
        }
        
        .node-value {
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="demo-header">
            <h1>Scene Graph Demo</h1>
            <p>Hierarchical scene management with parent-child relationships and transformations</p>
            <div class="demo-nav">
                <a href="index.html">‚Üê Back to Demos</a>
            </div>
        </div>

        <div class="demo-content">
            <div class="code-panel">
                <h3>Scene Graph Operations</h3>
                <div class="code-snippet">
                    <h4>Creating Scene Nodes</h4>
                    <pre><code>// Create a scene graph
const sceneGraph = new ThreeEdit.SceneGraph();

// Create nodes with meshes
const rootNode = new ThreeEdit.SceneNode('root', null);
const cubeNode = new ThreeEdit.SceneNode('cube', ThreeEdit.createCube());
const sphereNode = new ThreeEdit.SceneNode('sphere', ThreeEdit.createSphere());

// Add to scene graph
sceneGraph.addNode(rootNode);
sceneGraph.addChild(rootNode, cubeNode);
sceneGraph.addChild(cubeNode, sphereNode);</code></pre>
                </div>

                <div class="code-snippet">
                    <h4>Node Transformations</h4>
                    <pre><code>// Transform nodes
cubeNode.setPosition({ x: 2, y: 0, z: 0 });
cubeNode.setRotation({ x: 0, y: Math.PI / 4, z: 0 });
cubeNode.setScale({ x: 1.5, y: 1, z: 1 });

// Child inherits parent transformations
sphereNode.setPosition({ x: 0, y: 1, z: 0 });</code></pre>
                </div>

                <div class="code-snippet">
                    <h4>Scene Traversal</h4>
                    <pre><code>// Traverse all nodes
sceneGraph.traverse((node) => {
    console.log('Node:', node.name);
    if (node.mesh) {
        console.log('Mesh vertices:', node.mesh.vertices.length);
    }
});

// Find specific node
const foundNode = sceneGraph.findNodeById('cube');</code></pre>
                </div>

                <div class="code-snippet">
                    <h4>Converting to Three.js Scene</h4>
                    <pre><code>// Convert scene graph to Three.js scene
const threeScene = ThreeEdit.toThreeScene(sceneGraph);

// Or convert individual node
const threeMesh = ThreeEdit.toBufferGeometry(node.mesh);
const material = new THREE.MeshPhongMaterial({ color: 0x667eea });
const mesh = new THREE.Mesh(threeMesh, material);</code></pre>
                </div>
            </div>

            <div class="viewport-panel">
                <div id="viewport"></div>
                <div class="viewport-controls">
                    <button onclick="resetScene()">Reset Scene</button>
                    <button onclick="exportScene()">Export Scene</button>
                    <button onclick="importScene()">Import Scene</button>
                </div>
            </div>

            <div class="controls-panel">
                <h3>Scene Graph Controls</h3>
                
                <div class="control-group">
                    <label for="node-type">Node Type:</label>
                    <select id="node-type" onchange="updateNodeType()">
                        <option value="cube">Cube</option>
                        <option value="sphere">Sphere</option>
                        <option value="cylinder">Cylinder</option>
                        <option value="torus">Torus</option>
                        <option value="empty">Empty Node</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="node-name">Node Name:</label>
                    <input type="text" id="node-name" value="node" placeholder="Enter node name">
                </div>

                <div class="control-group">
                    <label for="parent-node">Parent Node:</label>
                    <select id="parent-node" onchange="updateParentNode()">
                        <option value="root">Root</option>
                    </select>
                </div>

                <div class="control-group">
                    <button onclick="addNode()">Add Node</button>
                    <button onclick="removeSelectedNode()">Remove Node</button>
                    <button onclick="duplicateNode()">Duplicate Node</button>
                </div>

                <div class="control-group">
                    <h4>Transform Controls</h4>
                    <label for="pos-x">Position X:</label>
                    <input type="range" id="pos-x" min="-5" max="5" step="0.1" value="0" onchange="updateNodeTransform()">
                    <span id="pos-x-value">0</span>
                    
                    <label for="pos-y">Position Y:</label>
                    <input type="range" id="pos-y" min="-5" max="5" step="0.1" value="0" onchange="updateNodeTransform()">
                    <span id="pos-y-value">0</span>
                    
                    <label for="pos-z">Position Z:</label>
                    <input type="range" id="pos-z" min="-5" max="5" step="0.1" value="0" onchange="updateNodeTransform()">
                    <span id="pos-z-value">0</span>
                </div>

                <div class="control-group">
                    <label for="rot-x">Rotation X:</label>
                    <input type="range" id="rot-x" min="-3.14" max="3.14" step="0.1" value="0" onchange="updateNodeTransform()">
                    <span id="rot-x-value">0</span>
                    
                    <label for="rot-y">Rotation Y:</label>
                    <input type="range" id="rot-y" min="-3.14" max="3.14" step="0.1" value="0" onchange="updateNodeTransform()">
                    <span id="rot-y-value">0</span>
                    
                    <label for="rot-z">Rotation Z:</label>
                    <input type="range" id="rot-z" min="-3.14" max="3.14" step="0.1" value="0" onchange="updateNodeTransform()">
                    <span id="rot-z-value">0</span>
                </div>

                <div class="control-group">
                    <label for="scale-x">Scale X:</label>
                    <input type="range" id="scale-x" min="0.1" max="3" step="0.1" value="1" onchange="updateNodeTransform()">
                    <span id="scale-x-value">1</span>
                    
                    <label for="scale-y">Scale Y:</label>
                    <input type="range" id="scale-y" min="0.1" max="3" step="0.1" value="1" onchange="updateNodeTransform()">
                    <span id="scale-y-value">1</span>
                    
                    <label for="scale-z">Scale Z:</label>
                    <input type="range" id="scale-z" min="0.1" max="3" step="0.1" value="1" onchange="updateNodeTransform()">
                    <span id="scale-z-value">1</span>
                </div>

                <div class="scene-tree" id="scene-tree">
                    <div>Scene Tree:</div>
                    <div class="tree-node selected" onclick="selectNode('root')">üìÅ root</div>
                </div>

                <div class="node-info" id="node-info">
                    <div>Selected Node: <span class="node-property">root</span></div>
                    <div>Type: <span class="node-value">Empty</span></div>
                    <div>Children: <span class="node-value">0</span></div>
                    <div>Position: <span class="node-value">(0, 0, 0)</span></div>
                    <div>Rotation: <span class="node-value">(0, 0, 0)</span></div>
                    <div>Scale: <span class="node-value">(1, 1, 1)</span></div>
                </div>
            </div>
        </div>

        <div class="status-bar" id="status-bar">
            Scene graph ready
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="../dist/umd/index.umd.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let sceneGraph = null;
        let selectedNode = null;
        let nodeCounter = 1;
        let meshObjects = [];
        let nodeObjects = new Map();

        // Initialize the scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
            camera.position.set(10, 10, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(800, 600);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const viewport = document.getElementById('viewport');
            viewport.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Initialize scene graph
            initSceneGraph();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = 800 / 600;
            camera.updateProjectionMatrix();
            renderer.setSize(800, 600);
        }

        function initSceneGraph() {
            sceneGraph = new ThreeEdit.SceneGraph();
            const rootNode = new ThreeEdit.SceneNode('root', null);
            sceneGraph.addNode(rootNode);
            selectedNode = rootNode;
            updateSceneTree();
            updateNodeInfo();
            updateStatus('Scene graph initialized');
        }

        function addNode() {
            if (!selectedNode) {
                updateStatus('No parent node selected', 'error');
                return;
            }

            const nodeType = document.getElementById('node-type').value;
            const nodeName = document.getElementById('node-name').value || `node_${nodeCounter++}`;
            
            let mesh = null;
            if (nodeType !== 'empty') {
                const meshName = 'create' + nodeType.charAt(0).toUpperCase() + nodeType.slice(1);
                if (ThreeEdit[meshName]) {
                    mesh = ThreeEdit[meshName]();
                } else {
                    updateStatus('Mesh type not available: ' + nodeType, 'error');
                    return;
                }
            }

            const newNode = new ThreeEdit.SceneNode(nodeName, mesh);
            sceneGraph.addChild(selectedNode, newNode);
            
            addNodeToScene(newNode);
            updateSceneTree();
            updateParentNodeOptions();
            updateStatus('Node added: ' + nodeName);
        }

        function addNodeToScene(node) {
            if (node.mesh) {
                const geometry = ThreeEdit.toBufferGeometry(node.mesh);
                const material = new THREE.MeshPhongMaterial({ 
                    color: getRandomColor(), 
                    transparent: true, 
                    opacity: 0.8 
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Apply node transformation
                const transform = node.getWorldTransform();
                mesh.position.copy(transform.position);
                mesh.rotation.set(transform.rotation.x, transform.rotation.y, transform.rotation.z);
                mesh.scale.copy(transform.scale);
                
                scene.add(mesh);
                meshObjects.push(mesh);
                nodeObjects.set(node, mesh);
                
                // Add wireframe
                const wireframe = new THREE.WireframeGeometry(geometry);
                const line = new THREE.LineSegments(wireframe);
                line.material.color.setHex(0x000000);
                line.material.transparent = true;
                line.material.opacity = 0.3;
                line.position.copy(mesh.position);
                line.rotation.copy(mesh.rotation);
                line.scale.copy(mesh.scale);
                scene.add(line);
                meshObjects.push(line);
            }
        }

        function removeSelectedNode() {
            if (!selectedNode || selectedNode.name === 'root') {
                updateStatus('Cannot remove root node', 'error');
                return;
            }

            // Remove from scene
            const mesh = nodeObjects.get(selectedNode);
            if (mesh) {
                scene.remove(mesh);
                meshObjects = meshObjects.filter(obj => obj !== mesh);
                nodeObjects.delete(selectedNode);
            }

            // Remove from scene graph
            sceneGraph.removeNode(selectedNode);
            selectedNode = sceneGraph.getRoot();
            
            updateSceneTree();
            updateParentNodeOptions();
            updateNodeInfo();
            updateStatus('Node removed');
        }

        function duplicateNode() {
            if (!selectedNode || !selectedNode.mesh) {
                updateStatus('Cannot duplicate empty node', 'error');
                return;
            }

            const nodeName = selectedNode.name + '_copy';
            const newNode = new ThreeEdit.SceneNode(nodeName, selectedNode.mesh);
            
            // Copy transformation
            const transform = selectedNode.getTransform();
            newNode.setTransform(transform);
            
            sceneGraph.addChild(selectedNode.parent, newNode);
            addNodeToScene(newNode);
            
            updateSceneTree();
            updateParentNodeOptions();
            updateStatus('Node duplicated: ' + nodeName);
        }

        function selectNode(nodeName) {
            const node = sceneGraph.findNodeById(nodeName);
            if (node) {
                selectedNode = node;
                updateSceneTree();
                updateNodeInfo();
                updateTransformControls();
                updateStatus('Selected node: ' + nodeName);
            }
        }

        function updateNodeTransform() {
            if (!selectedNode) return;

            const position = {
                x: parseFloat(document.getElementById('pos-x').value),
                y: parseFloat(document.getElementById('pos-y').value),
                z: parseFloat(document.getElementById('pos-z').value)
            };

            const rotation = {
                x: parseFloat(document.getElementById('rot-x').value),
                y: parseFloat(document.getElementById('rot-y').value),
                z: parseFloat(document.getElementById('rot-z').value)
            };

            const scale = {
                x: parseFloat(document.getElementById('scale-x').value),
                y: parseFloat(document.getElementById('scale-y').value),
                z: parseFloat(document.getElementById('scale-z').value)
            };

            selectedNode.setTransform({ position, rotation, scale });
            updateSceneVisualization();
            updateNodeInfo();
        }

        function updateTransformControls() {
            if (!selectedNode) return;

            const transform = selectedNode.getTransform();
            
            document.getElementById('pos-x').value = transform.position.x;
            document.getElementById('pos-y').value = transform.position.y;
            document.getElementById('pos-z').value = transform.position.z;
            document.getElementById('pos-x-value').textContent = transform.position.x.toFixed(2);
            document.getElementById('pos-y-value').textContent = transform.position.y.toFixed(2);
            document.getElementById('pos-z-value').textContent = transform.position.z.toFixed(2);

            document.getElementById('rot-x').value = transform.rotation.x;
            document.getElementById('rot-y').value = transform.rotation.y;
            document.getElementById('rot-z').value = transform.rotation.z;
            document.getElementById('rot-x-value').textContent = transform.rotation.x.toFixed(2);
            document.getElementById('rot-y-value').textContent = transform.rotation.y.toFixed(2);
            document.getElementById('rot-z-value').textContent = transform.rotation.z.toFixed(2);

            document.getElementById('scale-x').value = transform.scale.x;
            document.getElementById('scale-y').value = transform.scale.y;
            document.getElementById('scale-z').value = transform.scale.z;
            document.getElementById('scale-x-value').textContent = transform.scale.x.toFixed(2);
            document.getElementById('scale-y-value').textContent = transform.scale.y.toFixed(2);
            document.getElementById('scale-z-value').textContent = transform.scale.z.toFixed(2);
        }

        function updateSceneVisualization() {
            // Clear existing meshes
            meshObjects.forEach(obj => scene.remove(obj));
            meshObjects = [];
            nodeObjects.clear();

            // Rebuild scene from scene graph
            sceneGraph.traverse((node) => {
                if (node.mesh) {
                    addNodeToScene(node);
                }
            });
        }

        function updateSceneTree() {
            const treeContainer = document.getElementById('scene-tree');
            treeContainer.innerHTML = '<div>Scene Tree:</div>';
            
            function addNodeToTree(node, depth = 0) {
                const indent = '  '.repeat(depth);
                const icon = node.mesh ? 'üì¶' : 'üìÅ';
                const className = node === selectedNode ? 'tree-node selected' : 'tree-node';
                const nodeElement = document.createElement('div');
                nodeElement.className = className;
                nodeElement.style.marginLeft = (depth * 20) + 'px';
                nodeElement.textContent = `${indent}${icon} ${node.name}`;
                nodeElement.onclick = () => selectNode(node.name);
                treeContainer.appendChild(nodeElement);
                
                // Add children
                node.children.forEach(child => {
                    addNodeToTree(child, depth + 1);
                });
            }
            
            addNodeToTree(sceneGraph.getRoot());
        }

        function updateNodeInfo() {
            if (!selectedNode) return;

            const info = document.getElementById('node-info');
            const transform = selectedNode.getTransform();
            
            info.innerHTML = `
                <div>Selected Node: <span class="node-property">${selectedNode.name}</span></div>
                <div>Type: <span class="node-value">${selectedNode.mesh ? 'Mesh' : 'Empty'}</span></div>
                <div>Children: <span class="node-value">${selectedNode.children.length}</span></div>
                <div>Position: <span class="node-value">(${transform.position.x.toFixed(2)}, ${transform.position.y.toFixed(2)}, ${transform.position.z.toFixed(2)})</span></div>
                <div>Rotation: <span class="node-value">(${transform.rotation.x.toFixed(2)}, ${transform.rotation.y.toFixed(2)}, ${transform.rotation.z.toFixed(2)})</span></div>
                <div>Scale: <span class="node-value">(${transform.scale.x.toFixed(2)}, ${transform.scale.y.toFixed(2)}, ${transform.scale.z.toFixed(2)})</span></div>
            `;
        }

        function updateParentNodeOptions() {
            const select = document.getElementById('parent-node');
            select.innerHTML = '<option value="root">Root</option>';
            
            sceneGraph.traverse((node) => {
                if (node.name !== 'root') {
                    const option = document.createElement('option');
                    option.value = node.name;
                    option.textContent = node.name;
                    select.appendChild(option);
                }
            });
        }

        function updateNodeType() {
            const nodeType = document.getElementById('node-type').value;
            updateStatus('Node type changed to: ' + nodeType);
        }

        function updateParentNode() {
            const parentName = document.getElementById('parent-node').value;
            updateStatus('Parent node changed to: ' + parentName);
        }

        function resetScene() {
            // Clear scene
            meshObjects.forEach(obj => scene.remove(obj));
            meshObjects = [];
            nodeObjects.clear();
            
            // Reinitialize scene graph
            initSceneGraph();
            updateStatus('Scene reset');
        }

        function exportScene() {
            const sceneData = ThreeEdit.toJSON(sceneGraph);
            const dataStr = JSON.stringify(sceneData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'scene-graph.json';
            link.click();
            
            updateStatus('Scene exported');
        }

        function importScene() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const sceneData = JSON.parse(e.target.result);
                            sceneGraph = ThreeEdit.createFromJSON(sceneData);
                            selectedNode = sceneGraph.getRoot();
                            
                            updateSceneVisualization();
                            updateSceneTree();
                            updateParentNodeOptions();
                            updateNodeInfo();
                            updateTransformControls();
                            
                            updateStatus('Scene imported successfully');
                        } catch (error) {
                            updateStatus('Error importing scene: ' + error.message, 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function getRandomColor() {
            const colors = [0x667eea, 0xf5576c, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xfeca57];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function updateStatus(message, type = 'info') {
            const statusBar = document.getElementById('status-bar');
            statusBar.textContent = message;
            statusBar.className = 'status-bar ' + type;
        }

        // Initialize when page loads
        window.addEventListener('load', initScene);
        window.addEventListener('resize', onWindowResize);

        // Add keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'Delete':
                    removeSelectedNode();
                    break;
                case 'd':
                    if (event.ctrlKey) duplicateNode();
                    break;
                case 'n':
                    if (event.ctrlKey) addNode();
                    break;
            }
        });
    </script>
</body>
</html> 